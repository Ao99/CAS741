\documentclass[12pt, titlepage]{article}

\input{../../Comments}
\input{../../Common}

\externaldocument{../../SRS/CA}

\begin{document}

\title{Module Interface Specification for \progname}

\author{Ao Dong}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Nov 25 & 1.0 & Initial Draft\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at
\url{https://github.com/Ao99/MIA/blob/master/docs/SRS/CA.pdf}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
\progname{} which is for medical image segmentation.

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/Ao99/MIA}.

\section{Notation}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$. This
document has one modification to the original notations: the concatenation
notation $||$ can be used to build a new sequence from an existing sequence. For
example, s2 $:= ||(x : \mathbb{N} | x \in s1 \cdot x+1)$, where s1 = $\langle
1,2,...,10 \rangle$, then s2 = $\langle 2,3,...,11 \rangle$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$,
$\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1,
$\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
boolean & boolean & a value in $\{true, false\}$\\
\bottomrule
\end{tabular} 
\end{center}

The following table summarizes other data types used by \progname.
\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
DICOM file & inputFile & a DICOM image file\\
DICOM frame & dcmFrame & a frame of image in a DICOM image file\\
image data & imageData & a data structure containing width, height and a
sequence of pixel values\\
bitmap file & outputFile & an 8-bit 2D grayscale bitmap image file\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences,
strings, and
tuples. Sequences are lists filled with elements of the same data type. strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this
project.

\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

{Hardware-Hiding Module} & ~ \\
\midrule

\multirow{6}{0.3\textwidth}{Behaviour-Hiding Module}
& Input Module\\
& Output Module\\
& Optimal Thresholds Calculation\\
& Image Verification\\
& Constant Values\\
& Control Module\\
\midrule

\multirow{2}{0.3\textwidth}{Software Decision Module}
& Sequence Data Structure\\
& Image Data Structure\\
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\newpage

\section{MIS of Control Module} \label{Md_Control}
\subsection{Module}
main
\subsection{Uses}

Input in Section \ref{Md_Input}, ThresCal in Section \ref{Md_Calculation},
Output in Section \ref{Md_Output}

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{2cm} p{2cm} p{6cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
main & - & - & emptyloadedImage, badThresholds, badMethodChoice\\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

None

\subsubsection{Access Routine Semantics}

\noindent main():
\begin{itemize}
\item transition: use other modules by following these steps
\begin{enumerate}
    \item Get (filenameIn: string) and (filenameOut: string) from user
    \item
    Input.loadInput($filenameIn$)
    \item
    For ($j: \mathbb{N}$) from 0 to Input.numFrames, repeat the following steps
    \item
(Input.isLoaded($j$) = true $\implies$ ThresCal.calculation($j$) $|$ else
$\implies$ emptyloadedImage)
    \item
(ThresCal.validThresholds = true $\implies$ Output.displayThresholds() $|$ else
$\implies$ badThresholds)
\item (ThresCal.methodChoice $\in \{$Constants.CHOICE1, Constants.CHOICE2$\}
\implies$ Output.writeOutput(filenameOut) $|$ else $\implies$ badMethodChoice)
\end{enumerate}
\item output: none
\item exception: $exc :=$\\
Input.isLoaded[$j$] = $false \implies$ emptyloadedImage\\
ThresCal.validThresholds = $false \implies$ badThresholds\\
ThresCal.methodChoice $\not\in \{$Constants.CHOICE1, Constants.CHOICE2$\}
\implies$ badMethodChoice
\end{itemize}

\subsubsection{Local Functions}

None

\newpage

\section{MIS of Constant Values} \label{Md_Constants}
\subsection{Module}
Constants
\subsection{Uses}

None

\subsection{Syntax}

\subsubsection{Exported Constants}

MINX := 10\\
MAXX := 1000\\
MINY := 10\\
MAXY := 1000\\
CHOICE1 := 1\\
CHOICE2 := 2\\
EMPTY := 0


\subsubsection{Access Routine Semantics}
N/A

\newpage

\section{MIS of Input Module} \label{Md_Input}
\subsection{Module}

Input

\subsection{Uses}

Image Data Structure \ref{Md_ImageDS}, Image Verification in Section
\ref{Md_Verify}

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{2cm} p{5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
loadInput & $s$: string & - & FileError\\
verifyInput & & - & \\
loadedImages & - & sequence of imageData\\
numFrames & - & $\mathbb{N}$ & \\
isLoaded & - & sequence of boolean\\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

loadedImages: sequence of imageData\\
numFrames: $\mathbb{N}$\\
isLoaded: sequence of boolean

\subsubsection{Environment Variables}

inputFile: a .dcm or .dcm30 DICOM medical image file

\subsubsection{Assumptions}

The data type String has a method parseToNum() to parse a string (such as ``1")
to an $\mathbb{N}$ (such as 1).

\subsubsection{Access Routine Semantics}

\noindent Input.loadedImages:
\begin{itemize}
\item output: $out:=$ loadedImages 
\item exception: none 
\end{itemize}

\noindent Input.numFrames:
\begin{itemize}
\item output: $out:=$ numFrames 
\item exception: none 
\end{itemize}

\noindent Input.isLoaded:
\begin{itemize}
\item output: $out:=$ isLoaded 
\item exception: none 
\end{itemize}

\noindent loadInput($s$):
\begin{itemize}
\item transition: 
The filename $s$ is first associated with the file f. inputFile is used to
modify
the state variables using the following procedural specification:
\begin{enumerate}
    \item Read the inputFile.
    \item
    numFrames := information from inputFile
    \item
loadedImages := $||$($f$ : dcmFrame $|$ $f \in $ inputFile $\cdot$
dcmToImage($f$))
    \item
    verifyInput()
\end{enumerate}
\item output: none
\item exception: $exc :=$ a file name $s$ cannot be found or the format of
inputFile is incorrect
$\implies$ FileError
\end{itemize}

\noindent verifyInput():
\begin{itemize}
\item transition: 
This function modifies the state variables using the following procedural
specification:
\begin{enumerate}
    \item
isLoaded := $||$($img$ : imageData $|$ $img \in$ loadedImages $\cdot$
ImageVerify.verify1File($img$))
\end{enumerate}
\item output: none 
\item exception: none
\end{itemize}

\subsubsection{Local Functions}

\noindent dcmToImage: dcmFrame $\rightarrow$ imageData\\
\noindent dcmToImage($f$) $\equiv$ ImageData($f.x$, $f.y$,
stringToSequence($f.s$))

\noindent stringToSequence: string $\rightarrow$ sequence of $\mathbb{N}$

\noindent stringToSequence($str$) $\equiv$
$||$ ($pv$: string $|$ $pv \in$ dcmFrame $\cdot$ String.parseToNum($pv$))\\
$pv$ is a string containing grayscale value for one pixel.

\newpage

\section{MIS of Image Data Structure} \label{Md_ImageDS}
\subsection{Module}

ImageData

\subsection{Uses}

Constant Values \ref{Md_Constants}

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{3cm} p{5cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
ImageData & $x: \mathbb{N}$, $y: \mathbb{N}$, $p$: sequence of $\mathbb{N}$ &
imageData & badWidthInput, badHeightInput, badPixelValueLength\\
width & - & $\mathbb{N}$\\
height & - & $\mathbb{N}$ & \\
pixelValue & - & sequence of $\mathbb{N}$\\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

width: $\mathbb{N}$\\
height: $\mathbb{N}$\\
pixelValue: sequence

\subsubsection{Environment Variables}

none

\subsubsection{Assumptions}

We only need images with width and height not less than Constants.MINX or
Constants.MINY, and not greater than Constants.MAXX or Constants.MAXY.

\subsubsection{Access Routine Semantics}

\noindent Input.width:
\begin{itemize}
\item output: $out:=$ width 
\item exception: none 
\end{itemize}

\noindent Input.height:
\begin{itemize}
\item output: $out:=$ height 
\item exception: none 
\end{itemize}

\noindent Input.isLoaded:
\begin{itemize}
\item output: $out:=$ isLoaded 
\item exception: none 
\end{itemize}

\noindent ImageData($x, y, p$):
\begin{itemize}
\item transition: 
The parameters $x$ and $y$ are natural numbers, $p$ is a sequence of natural
numbers representing the pixel values from left to right, top to bottom.
ImageData() is the conxtructor of this data structure, and it modifies
the state variables using the following procedural specification:
\begin{enumerate}
    \item
    height $:= x$
    \item
    height $:= y$
    \item
    pixelValue $:= p$
\end{enumerate}
\item output: := itself
\item exception: $exc :=$\\
$x \not\in [Constants.MINX,Constants.MAXX] \implies$ badWidthInput\\
$y \not\in [Constants.MINY,Constants.MAXY] \implies$ badHeightInput\\
$p.length \not= x \times y \implies$ badPixelValueLength
\end{itemize}

\subsubsection{Local Functions}
None

\newpage

\section{MIS of Optimal Thresholds Calculation} \label{Md_Calculation}

\subsection{Module}

ThresCal

\subsection{Uses}

Constant Values \ref{Md_Constants}, Input in Section \ref{Md_Input}, Image Data
Structure \ref{Md_ImageDS}

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{2cm} p{2cm} p{6cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
calculation & $j: \mathbb{N}$ & - & badResult1, badResult2\\
getMethodChoice & $c: \mathbb{N}$ & - & badChoiceInput \\
imageIndex & - & $\mathbb{N}$ &  \\
methodChoice & - & $\mathbb{N}$ &  \\
validThresholds & - & boolean &\\
k1 & - & $\mathbb{N}$ &  \\
k2 & - & $\mathbb{N}$ &  \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

imageIndex: $\mathbb{N}$\\
methodChoice: string\\
validThresholds: boolean\\
k1: $\mathbb{N}$\\
k2: $\mathbb{N}$

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

None

\subsubsection{Access Routine Semantics}

\noindent ThresCal.imageIndex:
\begin{itemize}
\item output: $out :=$ imageIndex
\item exception: none 
\end{itemize}

\noindent ThresCal.methodChoice:
\begin{itemize}
\item output: $out :=$ methodChoice
\item exception: none 
\end{itemize}

\noindent ThresCal.validThresholds:
\begin{itemize}
\item output: $out :=$ validThresholds
\item exception: none 
\end{itemize}

\noindent ThresCal.k1:
\begin{itemize}
\item output: $out :=$ k1
\item exception: none 
\end{itemize}

\noindent ThresCal.k2:
\begin{itemize}
\item output: $out :=$ k2
\item exception: none 
\end{itemize}

\noindent calculation($j$):\\
$j \in \mathbb{N}$ is the index of one imageData in the Input.loadedImages
sequence.
\begin{itemize}
\item transition:
This function modifies
the state variables using the following procedural specification:
\begin{enumerate}
    \item
    imageIndex $:= j$
    \item
    getMethodChoice()
    \item
    According to chosen method, calculate $k1$ or both $k1$ and $k2$:\\
    if methodChoice = Constants.CHOICE1,
\begin{itemize}
\item $k1 := k1 \in$ [1, 254]. sigma2b1($k1$) = $\max\limits_{0< t1<255}$
sigma2b1($t1$)
    \item $k2 := Constants.EMPTY$
\item validThresholds $:= (k1 \in [1, 254] \implies true |\ else \implies
false)$
\end{itemize}
if methodChoice = Constants.CHOICE2,
\begin{itemize}
\item $k1 := k1 \in [1, 254].\ k1 < k2 \land sigma2b2(k1,k2) =
\max\limits_{0<t1<t2<255} sigma2b2(t1,t2))$
\item $k2 := k2 \in [1, 254].\ k1 < k2 \land sigma2b2(k1,k2) =
\max\limits_{0<t1<t2<255} sigma2b2(t1,t2)$
\item validThresholds $:= (k1 \in$ [1, 254] $\land k2 \in$ [1, 254] $\implies$
true $|$ else $\implies$ false)
\end{itemize}
\end{enumerate}
\item output: none
\item exception: $exc :=$\\
methodChoice = Constants.CHOICE1 $\land k1 \not\in [1, 254] \implies$
badResult1\\
methodChoice = Constants.CHOICE2 $\land (k1 \not\in [1,k2) \lor k2 \not\in (k1,
254] \implies$ badResult2
\end{itemize}

\noindent getMethodChoice($c$):
\begin{itemize}
\item transition:
The parameter $c$ is a natural number representing user's choice. This function
modifies the state variables using the following procedural specification:
\begin{enumerate}
    \item
Use hardware to display a message, asking for user's input ``1" or ``2 " for
method choice.
    \item
methodChoice := ($c \in \{$Constants.CHOICE1, Constants.CHOICE2$\} \implies c\
|\ else \implies$ Constants.EMPTY)
\end{enumerate}
\item output: none
\item exception: $exc := c \not\in \{$Constants.CHOICE1, Constants.CHOICE2$\}
\implies$ badChoiceInput
\end{itemize}

\subsubsection{Local Functions}

n: $\mathbb{N} \times \mathbb{N} \rightarrow \mathbb{N}$\\
n($i,j) \equiv +(pv.\mathbb{N} |pv \in Input.loadedImages[j].pixelValue \cdot
(pv = i \implies 1 | else \implies 0))$\\
p: $\mathbb{N} \times \mathbb{N} \rightarrow \mathbb{R}$\\
p($i,j) \equiv n(i,j)/(+(i.\mathbb{N} | i \in [0,255] \cdot n(i,j)))$\\
prb1: $\mathbb{N} \times \mathbb{N} \rightarrow \mathbb{R}$\\
prb1($t1,j) \equiv +(i.\mathbb{N} | i \in [0,t1] \cdot p(i,j))$\\
prb2: $\mathbb{N} \times \mathbb{N} \times \mathbb{N} \rightarrow \mathbb{R}$\\
prb2($t1,t2,j) \equiv +(i.\mathbb{N} | i \in [t1+1,t2] \cdot p(i,j))$\\
prb3: $\mathbb{N} \times \mathbb{N} \rightarrow \mathbb{R}$\\
prb3($t2,j) \equiv +(i.\mathbb{N} | i \in [t2+1,255] \cdot p(i,j))$\\
m1: $\mathbb{N} \times \mathbb{N} \rightarrow \mathbb{R}$\\
m1($t1,j) \equiv (+(i.\mathbb{N} | i \in [0,t1] \cdot i \times
p(i,j)))/prb1(t1,j)$\\
m2: $\mathbb{N} \times \mathbb{N} \times \mathbb{N} \rightarrow \mathbb{R}$\\
m2($t1,t2,j) \equiv (+(i.\mathbb{N} | i \in [t1+1,t2] \cdot i \times
p(i,j)))/prb2(t1,t2,j)$\\
m3: $\mathbb{N} \times \mathbb{N} \rightarrow \mathbb{R}$\\
m3($t2,j) \equiv (+(i.\mathbb{N} | i \in [t2+1,255] \cdot i \times
p(i,j)))/prb3(t2,j)$\\
mg: $\mathbb{N} \rightarrow \mathbb{R}$\\
mg($j) \equiv +(i.\mathbb{N} | i \in [0,255] \cdot i \times p(i,j))$\\
sigma2b1: $\mathbb{N} \times \mathbb{N} \rightarrow \mathbb{R}$\\
sigma2b1($t1,j) \equiv prb1(t1,j) \times (m1(t1,j)-mg(j))^2 + prb2(t1,255,j)
\times (m2(t1,255,j)-mg(j))^2$\\
sigma2b2: $\mathbb{N} \times \mathbb{N} \times \mathbb{N} \rightarrow
\mathbb{R}$\\
sigma2b2($t1,t2,j) \equiv prb1(t1,j) \times (m1(t1,j)-mg(j))^2 + prb2(t1,t2,j)
\times (m2(t1,t2,j)-mg(j))^2 + prb3(t2,j) \times (m3(t2,j)-mg(j))^2$\\

\newpage

\section{MIS of Output Module} \label{Md_Output}

\subsection{Module}

Output

\subsection{Uses}

Constant Values \ref{Md_Constants}, Image Data Structure \ref{Md_ImageDS},
ThresCal in Section \ref{Md_Calculation}, Image Verification in Section
\ref{Md_Verify}

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{2cm} p{2cm} p{6cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
displayThresholds & - & - &\\
writeOutput & $s$: string & - &
noAccess \\
createSegmentation & - & - &\\
segImage & - & imageData &  \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

segImage: imageData

\subsubsection{Environment Variables}

outputFile: a bitmap file

\subsubsection{Assumptions}

None

\subsubsection{Access Routine Semantics}

\noindent Output.segImage:
\begin{itemize}
\item output: $out :=$ segImage
\item exception: none 
\end{itemize}

\noindent displayThresholds():
\begin{itemize}
\item transition:
This function has the following procedural specification:
\begin{enumerate}
    \item
If methodChoice = Constants.CHOICE1, use Hardware-Hiding Module to display the
following message:\\
``Single-global-threshold method selected, the threshold value k= " + k1 + ``."    \item
If methodChoice = Constants.CHOICE2, use Hardware-Hiding Module to display the
following message:\\
``Multiple-global-threshold method selected, the threshold values k1= " + k1 +
``, k2= " + k2 + ``."
\end{enumerate}
\item output: none
\item exception: none
\end{itemize}

\noindent writeOutput($s$):
This method use segImage to write a outputFile to the environment using the
following procedural specification:
\begin{enumerate}
    \item createSegmentation()
    \item
(ImageVerify.verify1File($segImage$) = true $\implies$ continue $|$ else
$\implies$ stop)
    \item
Use local references $j$ for state variable in ThresCal: $j$ =
ThresCal.imageIndex
    \item
(ImageVerify.compare2Files($Input.loadedImages[j],segImage$) = true $\implies$
continue $|$ else $\implies$ stop)
    \item write a outputFile $s.bmp$ to the environment
\end{enumerate}
\begin{itemize}
\item transition: none
\item output: none
\item exception: $exc := $ no access to write a file to the output directory
$\implies$ noAccess
\end{itemize}

\noindent createSegmentation():
\begin{itemize}
\item transition:
This function modifies the state variables using the following procedural
specification:
\begin{enumerate}
    \item
    Use local references $j, c, k1, k2$ for state variables in ThresCal.
    \begin{itemize}
        \item $j$ = ThresCal.imageIndex
        \item $c$ = ThresCal.methodChoice
        \item $k1$ = ThresCal.ThresCal.k1
        \item $k2$ = ThresCal.ThresCal.k2
        \item $img$ := Input.loadedImages[$j$]
    \end{itemize}
    \item
    Initiate a sequence pixelValue[$img.x \times img.y$]
    \item
pixelValue := $|| (pv: \mathbb{N} | pv \in img.pixelValue \cdot (c =
$Constants.CHOICE1$ \implies (pv > k1 \implies 255 |\ else \implies 0) |\ c =
$Constants.CHOICE2$ \implies (pv > k2 \implies 255 |\ k2 \ge pv > k1 \implies
128 |\ else \implies 0))$
    \item
    segImage := ImageData($img.x,img.y,pixelValue$)
\end{enumerate}
\item output: none
\item exception: none
\end{itemize}

\subsubsection{Local Functions}

None

\newpage

\section{MIS of Image Verification} \label{Md_Verify}

\subsection{Module}

ImageVerify

\subsection{Uses}

Constant Values \ref{Md_Constants}

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{2cm} p{2cm} p{6cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
verify1File & imageData & boolean & emptyImage, badWidth, badHeight,
badPixelData\\
compare2Files & imageData, imageData & boolean & emptyImage1, emptyImage2,
badWidth2, badHeight2\\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

We only need images with width and height not less than Constants.MINX and
Constants.MINY, and not greater than Constants.MAXX and Constants.MAXY.

compare2Files(imageData, imageData) does not check if these two inputs are
valid, it assumes that during the previous steps, the software has called
verify1File(imageData) to verify these two inputs individually.

\subsubsection{Access Routine Semantics}

\noindent verify1File($img$):
The parameter $img$ is an instance of Image Data Structure.
\begin{itemize}
\item transition: none
\item output: $:= (img.x \in [Constants.MINX,Constants.MAXX] \land img.y \in
[Constants.MINY,\\
Constants.MAXY] \land
(\forall pv \in img.pixelValue.\ pv \in [0,255] \implies true |\ else \implies
false)$
\item exception: $exc :=$\\
$img$ is an empty instance of imageData type $\implies$ emptyImage\\
$x \not\in [Constants.MINX,Constants.MAXX] \implies$ badWidth\\
$y \not\in [Constants.MINY,Constants.MAXY] \implies$ badHeight\\
$\forall pv \in img.pixelValue.\ pv \not\in [0,255] \implies$ badPixelData
\end{itemize}

\noindent compare2Files($img1, img2$):
The parameters $img1$ and $img2$ are instances of Image Data Structure.
\begin{itemize}
\item transition: none
\item output: $:= ((img1.x = img2.x) \land (img1.y = img2.y) \implies true |\
else \implies false)$
\item exception: $exc :=$\\
$img1$ is an empty instance of imageData type $\implies$ emptyImage1\\
$img2$ is an empty instance of imageData type $\implies$ emptyImage2\\
$img1.x \not= img2.x \implies$ badWidth2\\
$img1.y \not= img2.y \implies$ badHeight2
\end{itemize}

\subsubsection{Local Functions}

None

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\renewcommand{\arraystretch}{1.2}

\begin{longtable}{l p{12cm}}
\caption{Possible Exceptions} \\
\toprule
\textbf{Message ID} & \textbf{Error Message} \\
\midrule
emptyloadedImage & Error: The image of frame $j$ is not loaded\\
badThresholds & Error: No correct thresholds have been calculated\\
badMethodChoice & Error: No correct segmentation method has been chosen\\
badWidthInput & Error: Image width must be $\in$ [Constants.MINX,
Constants.MAXX]\\
badHeightInput & Error: Image height must be $\in$ [Constants.MINX,
Constants.MAXX]\\
badPixelValueLength & Error: The length of image pixel value sequence must equal
to Constants.MINX $\times$ Constants.MAX\\
badResult1 & Error: $k1$ must be $\in$ [1, 254]\\
badResult2 & Error: $k1$ and $k2$ must follow this rule: $1 \le k1 < k2 \le
254$\\
badChoiceInput & Error: Must choose input from the set $\{$Constants.CHOICE1,
Constants.CHOICE2$\}$\\
emptyImage & Error: Cannot verify an empty image\\
badWidth & Error: Image width $\not\in$ [Constants.MINX, Constants.MAXX]\\
badHeight & Error: Image height $\not\in$ [Constants.MINX, Constants.MAXX]\\
badPixelData & Error: One or more pixel values $\not\in$ [0, 255]\\
emptyImage1 & Error: Cannot verify an empty original image\\
emptyImage2 & Error: Cannot verify an empty segmentation image\\
badWidth2 & Error: The original image and the segmentation image do not have the
same width\\
badHeight2 & Error: The original image and the segmentation image do not have
the same height\\
\bottomrule
\end{longtable}

\end{document}